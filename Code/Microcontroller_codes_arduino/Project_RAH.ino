/*
This code will display what movement the Arduino card user is doing, thanks of the NanoEdgeAI librairy found before.
Thanks to an app like LightBlue (availible on iOS and Android), you can receive datas in live.
To start, when using the dispositif with the Arduino card, you have to launch the app and then connect yourself to "Arduino".
Then, you click on the link permiting you to read and notify datas.
You have to choice, first you can read datas ie you can click on "read again" to read one information only when you want.
Else you can click on "Listen for notifications", it will display continuously all the informations about your movements.
*/


/* Configuration */

#include <Arduino_LSM9DS1.h> //accelerometer functions module
#include <ArduinoBLE.h> //bluetooth functions module

#include <NanoEdgeAI.h> //NanoEdgeAI functions and DATA_INPUT_USER, AXIS_NUMBER, CLASS_NUMBER define
#include <knowledge.h> //datas for the initialization

//Ble serive UUID generated by : https://www.guidgenerator.com/online-guid-generator.aspx
BLEService NanoEdgeAIService("11851262-7ce1-436f-8f29-998812b815ff");
//To be able reading informations sent by bluetooth
BLEUnsignedCharCharacteristic movementChar ("11851262-7ce1-436f-8f29-998812b815ff", BLERead | BLENotify);

//Datas structures for accelerations measure
float acc_buffer[DATA_INPUT_USER * AXIS_NUMBER] = { 0 }; //Accelerations buffer
float acc_x = 0.F;
float acc_y = 0.F;
float acc_z = 0.F;

//Datas strucutres for NanoEdgeAI
int class_threshold = 1; //0 means NanoEdgeAI_classifier returns the most likely class for a buffer
                         //1 means NanoEdgeAI_classifier returns a class  whose probability is greater than 0.5, or 0 otherwhise.
float output_buffer[CLASS_NUMBER] = {0};

/* Setup */

void setup() {
  //Serial configuration, waiting 3s in order to avoid any haste
  Serial.begin(9600);
  //while(!Serial);
  delay(4000);

  //LED configuration, to notify the advancement
  pinMode(LED_BUILTIN, OUTPUT);

  //NanoEdgeAI initialization
  uint8_t error_code = NanoEdgeAI_knowledge_init(knowledge);
  if (error_code != 0)
  {
    Serial.println("Datas could not be load");
  }

  //Modules initializing verifications
  if (!BLE.begin() || !IMU.begin())
  {
    Serial.println("Failed to initialize IMU or BLE!");
    while (1);
  }

  //BLE Service configuration : local name, adding service (UUID), setting initial value
  BLE.setLocalName("Movement");
  BLE.setAdvertisedService(NanoEdgeAIService);
  NanoEdgeAIService.addCharacteristic(movementChar);
  BLE.addService(NanoEdgeAIService);
  movementChar.writeValue(0);

  //Start advertising
  BLE.advertise();
  digitalWrite(LED_BUILTIN, HIGH);
  Serial.println("Waiting for bluetooth connexion on the app");
}


/* Loop */

void loop() {
  //Waiting for a bluetooth connection and for accelerations data
  BLEDevice central = BLE.central();
  if (central && IMU.accelerationAvailable())
  {
    digitalWrite(LED_BUILTIN, LOW);
    
    //Print the central's BT address:
    Serial.print("Connected to central: ");
    Serial.println(central.address());

    //Main loop
    int current_nb = 0;
    int actual_class = 0;
    int previous_class = 0;
    long previousMillis = 0;
    while(central.connected())
    {
        //We check the movement every 0.2sec. This avoids a disconnection due to a 'delay()'
        long currentMillis = millis();
        if (currentMillis - previousMillis >= 200)
        {
            fill_acc_buffer();
            actual_class = NanoEdgeAI_classifier(acc_buffer, output_class_buffer, class_threshold);
            
            //We consider that we are doing a new movement if we have 2 times in a row the same class for a better precision
            if (actual_class == previous_class && current_nb == 2)
            {
              Serial.print("Mouvement nb :");
              Serial.println(actual_class);
              
              movementChar.writeValue(actual_class);
              current_nb ++;
            }
            else if (actual_class == previous_class)
            {
              current_nb ++;
            }
            else if (actual_class != previous_class)
            {
              previous_class = actual_class;
              current_nb = 0;
            }
            previousMillis = currentMillis;
        }
      
    }
    Serial.print("Disconnected from central: ");
    Serial.println(central.address());    
  }
}

/* Functions */

void fill_acc_buffer() {
  //Acceleration buffer. Module frequency is set by default at 119Hz,
  //but there is no way to change it except to change it in the module main code.
    
    for (int i = 0; i < DATA_INPUT_USER; i++) {
      IMU.readAcceleration(acc_x, acc_y, acc_z);
      acc_buffer[AXIS_NUMBER * i] = acc_x;
      acc_buffer[AXIS_NUMBER * i + 1] = acc_y;
      acc_buffer[AXIS_NUMBER * i + 2] = acc_z;
    }
}

void get_acc_values() {
    //Prints the acceleration buffer's datas
    for (int i = 0; i < DATA_INPUT_USER; i++) 
    {
      Serial.print(acc_buffer[AXIS_NUMBER * i]);
      Serial.print(" ");
      Serial.print(acc_buffer[AXIS_NUMBER * i +1]);
      Serial.print(" ");
      Serial.println(acc_buffer[AXIS_NUMBER * i +2]);
    }

}

void get_output_values() {
  //Print each class probability
  for (int i =0; i < CLASS_NUMBER; i++)
  {
    Serial.print(output_class_buffer[i]);
    Serial.print(" ");
  }
}
